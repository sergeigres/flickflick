<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pixel Noise with Sound</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; background:black;
  }
  canvas {
    display:block;
  }
</style>
</head>
<body>

<canvas id="noiseCanvas"></canvas>

<script>
  // Canvas setup
  const canvas = document.getElementById('noiseCanvas');
  const ctx = canvas.getContext('2d');
  const pixelSize = 5;

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Web Audio API setup
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();

  // Create noise buffer
  function createNoiseBuffer() {
    const bufferSize = audioCtx.sampleRate * 2; // 2 seconds
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      output[i] = Math.random() * 2 - 1;
    }
    return buffer;
  }

  const noiseBuffer = createNoiseBuffer();

  // Create noise source, delay node, gain node
  let noiseSource = null;
  const delayNode = audioCtx.createDelay();
  const feedbackGain = audioCtx.createGain();
  const outputGain = audioCtx.createGain();

  delayNode.delayTime.value = 0.1;
  feedbackGain.gain.value = 0.3;
  outputGain.gain.value = 0.2;

  // Feedback loop for delay
  delayNode.connect(feedbackGain);
  feedbackGain.connect(delayNode);

  // Connect nodes
  // noiseSource -> delayNode -> outputGain -> destination
  // Also direct path noiseSource -> outputGain for mix
  function startNoise() {
    noiseSource = audioCtx.createBufferSource();
    noiseSource.buffer = noiseBuffer;
    noiseSource.loop = true;

    noiseSource.connect(delayNode);
    delayNode.connect(outputGain);
    noiseSource.connect(outputGain);

    outputGain.connect(audioCtx.destination);
    noiseSource.start();
  }

  // Start audio context on first user interaction
  function initAudio() {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    if (!noiseSource) startNoise();
  }

  window.addEventListener('click', initAudio, {once:true});

  // Pixel flicker with sound parameter modulation
  function getRandomColor() {
    const r = Math.floor(Math.random() * 256);
    const g = Math.floor(Math.random() * 256);
    const b = Math.floor(Math.random() * 256);
    return `rgba(${r},${g},${b},${Math.random()})`;
  }

  function flickerSoundParam() {
    // Randomly toggle delay on/off by changing feedback gain
    const delayOn = Math.random() > 0.5;
    feedbackGain.gain.value = delayOn ? Math.random() * 0.5 : 0;

    // Random delay time between 20ms and 300ms
    delayNode.delayTime.value = 0.02 + Math.random() * 0.28;

    // Random output volume (gain) between 0.1 and 0.3
    outputGain.gain.value = 0.1 + Math.random() * 0.2;
  }

  function drawNoise() {
    for (let y = 0; y < canvas.height; y += pixelSize) {
      for (let x = 0; x < canvas.width; x += pixelSize) {
        ctx.fillStyle = getRandomColor();
        ctx.fillRect(x, y, pixelSize, pixelSize);
      }
    }
  }

  function animate() {
    drawNoise();
    flickerSoundParam();
    requestAnimationFrame(animate);
  }

  animate();

</script>

</body>
</html>
