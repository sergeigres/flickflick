// === Canvas Setup ===
const canvas = document.getElementById('artCanvas');
const ctx = canvas.getContext('2d');
let w, h, pixelSize = 10;
let colorMode = true;
let animationFrame;
let pixelsMoving = true;

function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Video setup for camera input
const video = document.createElement('video');
video.autoplay = true;
video.style.display = 'none';
document.body.appendChild(video);

let cameraOn = false;

async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
    cameraOn = true;
  } catch (e) {
    console.error("Camera access denied:", e);
    cameraOn = false;
  }
}

function stopCamera() {
  if (video.srcObject) {
    video.srcObject.getTracks().forEach(track => track.stop());
  }
  cameraOn = false;
}

const hiddenCanvas = document.createElement('canvas');
const hiddenCtx = hiddenCanvas.getContext('2d');

// === Fullscreen Button ===
document.getElementById('fullscreenBtn').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

// === Audio Setup ===
const noiseTypes = ['white', 'pink', 'brown'];
let currentNoise = 'white';
let noise = new Tone.Noise(currentNoise).start();
let noiseGain = new Tone.Gain(0.5).toDestination();
let noiseFX = {
  delay: new Tone.FeedbackDelay("8n", 0.5),
  reverb: new Tone.Reverb(2),
  chorus: new Tone.Chorus(4, 2.5, 0.5),
  distortion: new Tone.Distortion(0.4)
};
noise.chain(noiseFX.delay, noiseFX.reverb, noiseFX.chorus, noiseFX.distortion, noiseGain);
noise.mute = true;

// Synth setup
const synth = new Tone.Synth({ oscillator: { type: 'sawtooth' } }).toDestination();
let synthEnabled = false;

// === Controls ===
const gui = new dat.GUI();
const controls = {
  pixelFlicker: true,
  noiseType: currentNoise,
  noiseOn: false,
  synthOn: false,
  pixelSize: 10,
  colorMode: true,
  delayTime: 0.5,
  reverbDecay: 2,
  distortionAmount: 0.4,
  chorusDepth: 0.5,
  pixelsMoving: true,
  cameraOn: false
};

gui.add(controls, 'noiseType', noiseTypes).onChange(type => {
  noise.stop();
  noise = new Tone.Noise(type).start();
  noise.chain(noiseFX.delay, noiseFX.reverb, noiseFX.chorus, noiseFX.distortion, noiseGain);
});
gui.add(controls, 'noiseOn').onChange(on => {
  noise.mute = !on;
});
gui.add(controls, 'synthOn').onChange(on => {
  synthEnabled = on;
});
gui.add(controls, 'pixelSize', 2, 50).step(1).onChange(v => pixelSize = v);
gui.add(controls, 'colorMode').onChange(v => colorMode = v);
gui.add(controls, 'delayTime', 0, 1).onChange(val => noiseFX.delay.delayTime.value = val);
gui.add(controls, 'reverbDecay', 0.1, 10).onChange(val => noiseFX.reverb.decay = val);
gui.add(controls, 'distortionAmount', 0, 1).onChange(val => noiseFX.distortion.distortion = val);
gui.add(controls, 'chorusDepth', 0, 1).onChange(val => noiseFX.chorus.depth = val);
gui.add(controls, 'pixelsMoving').name("Start/Stop Pixels").onChange(val => {
  pixelsMoving = val;
  if (pixelsMoving) animate();
  else cancelAnimationFrame(animationFrame);
});
gui.add(controls, 'cameraOn').name("Camera On/Off").onChange(async val => {
  if (val) await startCamera();
  else stopCamera();
});

// === Animation ===
function drawPixels() {
  if (cameraOn) {
    hiddenCanvas.width = w;
    hiddenCanvas.height = h;
    hiddenCtx.drawImage(video, 0, 0, w, h);
    const frame = hiddenCtx.getImageData(0, 0, w, h).data;

    for (let x = 0; x < w; x += pixelSize) {
      for (let y = 0; y < h; y += pixelSize) {
        const i = ((y * w) + x) * 4;
        let r = frame[i];
        let g = frame[i + 1];
        let b = frame[i + 2];

        if (!colorMode) {
          const gray = 0.299 * r + 0.587 * g + 0.114 * b;
          r = g = b = gray;
        }
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x, y, pixelSize, pixelSize);
      }
    }
  } else {
    // Draw random flickering pixels
    for (let x = 0; x < w; x += pixelSize) {
      for (let y = 0; y < h; y += pixelSize) {
        const r = Math.floor(Math.random() * 256);
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        const color = colorMode ? `rgb(${r},${g},${b})` : `rgb(${(r+g+b)/3}, ${(r+g+b)/3}, ${(r+g+b)/3})`;
        ctx.fillStyle = color;
        ctx.fillRect(x, y, pixelSize, pixelSize);
      }
    }
  }
}

function animate() {
  if (!pixelsMoving) return;
  drawPixels();
  animationFrame = requestAnimationFrame(animate);
}
animate();

// === Keyboard Synth ===
document.addEventListener('keydown', (e) => {
  if (!synthEnabled) return;

  const keys = {
    'a': 'C2', 'w': 'Db2', 's': 'D2', 'e': 'Eb2', 'd': 'E2',
    'f': 'F2', 't': 'Gb2', 'g': 'G2', 'y': 'Ab2', 'h': 'A2',
    'u': 'Bb2', 'j': 'B2', 'k': 'C3'
  };

  const note = keys[e.key];
  if (note) {
    synth.triggerAttackRelease(note, '8n');
    drawPixels(); // trigger pixel change on synth note
  }
});
